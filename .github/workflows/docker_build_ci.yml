# The beauty of this CI is that it will build every valid DOCKERFILE
# See the requirements at https://github.com/firepress-org/rclone-in-docker/blob/master/README-CI.md

name: docker_build_ci
on:
  pull_request:
  push:
  schedule:
    - cron:  '0 3 * * *'
    # everyday at 3 am
jobs:

  Job1:
    name: Job 1/2
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@master

      - name: A) Define our variables
        run: |
          cat Dockerfile | grep APP_NAME= | head -n 1 | grep -o '".*"' | sed 's/"//g' > APP_NAME
          cat Dockerfile | grep VERSION= | head -n 1 | grep -o '".*"' | sed 's/"//g' > DOCKERFILE_VERSION
          date -d "-4 hours" "+%Y-%m-%d_%HH%Ms%S" > DATE
          git rev-parse --short HEAD > SHORT_COMMIT_HASH
          echo "devmtl" > DOCKERHUB_USER
          echo "firepress-org" > GITHUB_USER
          echo "$(cat DOCKERHUB_USER)/$(cat APP_NAME)" > DOCKER_USER_APP
          echo "$(cat GITHUB_USER)/$(cat APP_NAME)" > GITHUB_USER_APP
          #
          # The way we define vars above is a hack. See why:
          # https://twitter.com/askpascalandy/status/1166535922160230406

      - name: B) Build image (UAT)
        run: |
          # UAT is User Acceptance Testing
          echo "$(cat APP_NAME):uat" > TAG_UAT
          echo "Lets build >>> $(cat TAG_UAT)"
          docker build --file Dockerfile --tag $(cat TAG_UAT) .
          #
          echo "Define the version of the app"
          # in ifself, this is a UAT
          $(docker run -it $(cat TAG_UAT) sh -c 'rclone --version' | head -n1 | sed 's/rclone v//g') > VERSION_IN_APP
    
      - name: C1) UAT with docker-library
        run: |
          git clone https://github.com/docker-library/official-images.git official-images
          official-images/test/run.sh $(cat TAG_UAT)

      - name: C2) UAT with Aquasec microscanner
        run: |
          wget --retry-connrefused --waitretry=1 --read-timeout=5 --timeout=5 --tries=10 https://raw.githubusercontent.com/lukebond/microscanner-wrapper/master/scan.sh && chmod +x scan.sh
          #
          echo "Build will stop only if it finds a critical issue"
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest -q --exit-code 1 --severity CRITICAL $(cat TAG_UAT)

      - name: D) Define image Tags
        run: |
          echo "$(cat DOCKER_USER_APP):$(cat VERSION_IN_APP)_$(cat DATE)_$(cat SHORT_COMMIT_HASH)" > TAG_BEST_PRACTICE
          echo "$(cat DOCKER_USER_APP):$(cat VERSION_IN_APP)" > TAG_VERSION
          echo "$(cat DOCKER_USER_APP):stable" > TAG_STABLE
          echo "$(cat DOCKER_USER_APP):latest" > TAG_LATEST
          #
          # DOCKERHUB_USER is hardcoded 
          # APP_NAME is taken from our Dockerfile
          # DOCKERFILE_VERSION is taken from our Dockerfile
          # VERSION_IN_APP is taken from the docker container itself
          # DATE is generated from our Ci system. Montreal time zone is 4 hours behind the CI system
          # SHORT_COMMIT_HASH is passed from our latest git commit

      - name: E1) Logs / Tags
        run: |
          echo "$(cat TAG_STABLE) < TAG_STABLE"
          echo "$(cat TAG_LATEST) < TAG_LATEST"
          echo "$(cat TAG_BEST_PRACTICE) < TAG_BEST_PRACTICE"
          echo "$(cat TAG_VERSION) < TAG_VERSION"
          echo "$(cat DOCKERFILE_VERSION) < DOCKERFILE_VERSION"
          #
          echo "Is there a delta between these versions? $VERSION_IN_APP versus $DOCKERFILE_VERSION"
          echo "ToDo/ notify on slack if there is a delta"

      - name: E2) Logs / docker logs
        run: |
          docker run -it --name $(cat TAG_UAT)
          docker logs $(cat TAG_UAT)

      - name: E3) Logs / docker inspect
        run: |
          docker inspect $(cat TAG_UAT)
          docker rm -f $(cat TAG_UAT)

      - name: E4) Logs / docker version + docker version info
        run: docker version && docker info

      - name: E5) Logs / uname
        run: uname -a

      - name: F) Build Dockerfile
        run: |
          docker build --file Dockerfile --tag $(cat TAG_BEST_PRACTICE) .
          docker build --file Dockerfile --tag $(cat TAG_VERSION) .
          docker build --file Dockerfile --tag $(cat TAG_STABLE) .
          docker build --file Dockerfile --tag $(cat TAG_LATEST) .
          #
          # build on GPR

      - name: G) Push docker image to registry
        run: |
          echo ${{ secrets.DOCKER_PASSWORD }} | docker login --username $(cat DOCKERHUB_USER) --password-stdin
          docker push $(cat TAG_BEST_PRACTICE)
          docker push $(cat TAG_VERSION)
          docker push $(cat TAG_STABLE)
          docker push $(cat TAG_LATEST)
          #
          # push on GPR
          echo "Check out https://hub.docker.com/r/$(cat DOCKERHUB_USER)/$(cat APP_NAME)/tags"
          #
          echo "ToDo/ Push to Github Package Registry (GPR)"
          echo "ToDo/ docker build -t docker.pkg.github.com/firepress-org/registry/$(cat TAG_BEST_PRACTICE)"
          echo "ToDo/ docker login docker.pkg.github.com -u firepress -p ${{ secrets.GPR_PASS }}"
          echo "ToDo/ docker push docker.pkg.github.com/firepress-org/registry/$(cat TAG_BEST_PRACTICE)"

  Job2:
    needs: job1
    name: Job 2/2
    runs-on: ubuntu-18.04
    steps:
      - uses: actions/checkout@master

      - name: H) Afterbuild (ideas & placeholder)
        run: |
          echo "ToDo/ notify me on slack"
          echo "ToDo/ push a webhook to our cluster. The CD part of CI/CD"
          echo "ToDo/ do an healthcheck in prod in case of a webapp"
